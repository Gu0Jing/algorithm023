
第5课：哈希表、映射、集合

1、哈希表：是一种通过哈希函数映射元素下标的数组
遇到哈希冲突时使用链表解决冲突：即拉链法

2、哈希表在工程中的应用：map和set
map：HashMap()，key唯一
set：HashSet()，元素唯一
HashSet内部就是一个HashMap，元素作为key

3、HashMap机制：
  初始化：默认构造一个容量为16的Node(实现了Entry)数组，装载因子0.75=元素个数/容量

  添加元素：通过hashcode(key)计算出下标存元素，
          如果已有元素，调用equals()比较key值，相同则替换并返回旧值，否则追加

  扩容：如果元素个数达到装载因子，启动扩容，每次扩容都是2的幂次倍，
       每次扩容都需要重新计算散列码，2的幂次倍扩容性能更好

  链表转化：发生冲突的哈希桶链表长度大于8，且容量大于64时，
          链表转化为红黑树，因为红黑树是平衡二叉树，查找性能优于链表
  为什么当链表长度大于8时转化：
       因为负载因子等于0.75的情况下根据泊松分布,单个hash槽内元素个数为8的概率小于百万分之一，
       所以将7作为一个分水岭，等于7的时候不转换，大于等于8的时候才进行转换，小于等于6的时候就化为链表

5：HashMap线程不安全：
   多线程并发场景下如果触发HashMap的扩容操作，由于重新计算索引下标，会造成数据丢失、死循环等问题，
   保证线程安全使用ConcurrentHashMap

6：重写类的equals方法时，必须重写hashcode()，满足规定：
    Java对于equals方法和hashCode方法是这样规定的：
          1、相等的对象必须具有相等的哈希码（或者散列码）。
          2、如果两个对象的hashCode相同，它们并不一定相同。
          A.equals(B)==true --> A.hashCode()==B.hashCode()
    保证通过equals判断相等的两个对象，调用hashCode方法要返回同样的整数值，否则不能保证预期
